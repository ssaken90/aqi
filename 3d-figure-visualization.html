<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –í–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem;
            text-align: center;
            color: white;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 1rem;
            padding: 1rem;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            min-width: 320px;
            max-width: 400px;
            height: fit-content;
        }

        .viewer-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
            min-height: 500px;
        }

        #canvas3d {
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .section h3 {
            color: #333;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .shape-btn {
            background: #f5f5f5;
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 1rem 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9rem;
            color: #555;
        }

        .shape-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .shape-btn.active {
            background: #2196f3;
            color: white;
            border-color: #1976d2;
        }

        .shape-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .inputs-grid {
            display: grid;
            gap: 1rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            color: #555;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .input-group input {
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #2196f3;
        }

        .input-group input:invalid {
            border-color: #f44336;
        }

        .units-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .unit-btn {
            background: #f5f5f5;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .unit-btn.active {
            background: #2196f3;
            color: white;
            border-color: #1976d2;
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-btn.active {
            border-color: #333;
            transform: scale(1.1);
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn {
            flex: 1;
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #2196f3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976d2;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #757575;
            color: white;
        }

        .btn-secondary:hover {
            background: #616161;
            transform: translateY(-2px);
        }

        .stats-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .stats-grid {
            display: grid;
            gap: 0.75rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-label {
            color: #666;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .stat-value {
            color: #333;
            font-weight: 600;
        }

        .viewer-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 10;
        }

        .mobile-hint {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
        }

        .mobile-hint.show {
            opacity: 1;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #333;
        }

        .control-btn:hover {
            background: white;
            transform: scale(1.05);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                padding: 0.5rem;
            }

            .controls-panel {
                min-width: unset;
                max-width: unset;
                order: 2;
            }

            .viewer-container {
                order: 1;
                min-height: 400px;
            }

            .shape-buttons {
                grid-template-columns: repeat(2, 1fr);
            }

            .color-picker {
                grid-template-columns: repeat(8, 1fr);
            }

            .action-buttons {
                flex-direction: column;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.4rem;
            }

            .controls-panel {
                padding: 1rem;
            }

            .shape-buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>3D –ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –í–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä</h1>
        <p>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É, –∑–∞–¥–∞–π—Ç–µ —Ä–∞–∑–º–µ—Ä—ã –∏ –∏—Å—Å–ª–µ–¥—É–π—Ç–µ –≤ 3D</p>
    </div>

    <div class="main-container">
        <div class="controls-panel">
            <div class="section">
                <h3>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É</h3>
                <div class="shape-buttons">
                    <div class="shape-btn active" data-shape="cube">
                        <span class="shape-icon">‚¨ú</span>
                        –ö—É–±
                    </div>
                    <div class="shape-btn" data-shape="cylinder">
                        <span class="shape-icon">ü•´</span>
                        –¶–∏–ª–∏–Ω–¥—Ä
                    </div>
                    <div class="shape-btn" data-shape="sphere">
                        <span class="shape-icon">‚ö™</span>
                        –®–∞—Ä
                    </div>
                    <div class="shape-btn" data-shape="pyramid">
                        <span class="shape-icon">üî∫</span>
                        –ü–∏—Ä–∞–º–∏–¥–∞
                    </div>
                    <div class="shape-btn" data-shape="cone">
                        <span class="shape-icon">üî∫</span>
                        –ö–æ–Ω—É—Å
                    </div>
                    <div class="shape-btn" data-shape="box">
                        <span class="shape-icon">üì¶</span>
                        –ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>–†–∞–∑–º–µ—Ä—ã</h3>
                <div class="inputs-grid" id="inputsContainer">
                    <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–µ –ø–æ–ª—è –≤–≤–æ–¥–∞ -->
                </div>
                <div class="units-selector">
                    <div class="unit-btn active" data-unit="cm">—Å–º</div>
                    <div class="unit-btn" data-unit="m">–º</div>
                    <div class="unit-btn" data-unit="in">–¥—é–π–º</div>
                </div>
            </div>

            <div class="section">
                <h3>–¶–≤–µ—Ç</h3>
                <div class="color-picker">
                    <div class="color-btn active" style="background: #2196f3" data-color="#2196f3"></div>
                    <div class="color-btn" style="background: #f44336" data-color="#f44336"></div>
                    <div class="color-btn" style="background: #4caf50" data-color="#4caf50"></div>
                    <div class="color-btn" style="background: #ff9800" data-color="#ff9800"></div>
                    <div class="color-btn" style="background: #9c27b0" data-color="#9c27b0"></div>
                    <div class="color-btn" style="background: #ffeb3b" data-color="#ffeb3b"></div>
                    <div class="color-btn" style="background: #795548" data-color="#795548"></div>
                    <div class="color-btn" style="background: #607d8b" data-color="#607d8b"></div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="showBtn">–ü–æ–∫–∞–∑–∞—Ç—å</button>
                <button class="btn btn-secondary" id="clearBtn">–û—á–∏—Å—Ç–∏—Ç—å</button>
            </div>

            <div class="stats-panel" id="statsPanel" style="display: none;">
                <h3>–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏</h3>
                <div class="stats-grid" id="statsGrid">
                    <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -->
                </div>
            </div>
        </div>

        <div class="viewer-container">
            <div class="viewer-controls">
                <button class="control-btn" id="resetViewBtn" title="–°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã">üéØ</button>
                <button class="control-btn" id="toggleGridBtn" title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å —Å–µ—Ç–∫—É">‚äû</button>
            </div>
            <div class="mobile-hint" id="mobileHint">
                üì± –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–π—Ç–µ –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º ‚Ä¢ –£–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏
            </div>
            <div class="loading" id="loadingText">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É –∏ –Ω–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å"</div>
            <canvas id="canvas3d"></canvas>
        </div>
    </div>

    <script>
        class GeometryVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.currentMesh = null;
                this.gridHelper = null;
                this.axesHelper = null;
                
                this.currentShape = 'cube';
                this.currentColor = '#2196f3';
                this.currentUnit = 'cm';
                
                this.shapes = {
                    cube: { params: ['side'], labels: ['–°—Ç–æ—Ä–æ–Ω–∞'] },
                    cylinder: { params: ['radius', 'height'], labels: ['–†–∞–¥–∏—É—Å', '–í—ã—Å–æ—Ç–∞'] },
                    sphere: { params: ['radius'], labels: ['–†–∞–¥–∏—É—Å'] },
                    pyramid: { params: ['base', 'height'], labels: ['–°—Ç–æ—Ä–æ–Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏—è', '–í—ã—Å–æ—Ç–∞'] },
                    cone: { params: ['radius', 'height'], labels: ['–†–∞–¥–∏—É—Å', '–í—ã—Å–æ—Ç–∞'] },
                    box: { params: ['length', 'width', 'height'], labels: ['–î–ª–∏–Ω–∞', '–®–∏—Ä–∏–Ω–∞', '–í—ã—Å–æ—Ç–∞'] }
                };

                this.unitFactors = {
                    cm: 1,
                    m: 100,
                    in: 2.54
                };

                this.init();
                this.setupEventListeners();
                this.updateInputs();
                this.checkMobileDevice();
            }

            checkMobileDevice() {
                // Show mobile hint on touch devices
                const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                if (isMobile) {
                    const hint = document.getElementById('mobileHint');
                    setTimeout(() => {
                        hint.classList.add('show');
                        setTimeout(() => {
                            hint.classList.remove('show');
                        }, 4000);
                    }, 1000);
                }
            }

            init() {
                const canvas = document.getElementById('canvas3d');
                const container = canvas.parentElement;

                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    container.clientWidth / container.clientHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(15, 15, 15);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(20, 20, 20);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Grid and axes
                this.gridHelper = new THREE.GridHelper(50, 50, 0x888888, 0xcccccc);
                this.scene.add(this.gridHelper);

                this.axesHelper = new THREE.AxesHelper(20);
                this.scene.add(this.axesHelper);

                // Controls (OrbitControls implementation)
                this.setupOrbitControls();

                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                this.animate();
            }

            setupOrbitControls() {
                // Enhanced orbit controls with touch support
                let isMouseDown = false;
                let isTouching = false;
                let mouseX = 0;
                let mouseY = 0;
                let targetRotationX = 0;
                let targetRotationY = 0;
                let rotationX = 0;
                let rotationY = 0;
                let lastTouchDistance = 0;

                const canvas = this.renderer.domElement;

                // Helper function to get touch coordinates
                const getTouchPos = (touch) => {
                    const rect = canvas.getBoundingClientRect();
                    return {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top
                    };
                };

                // Helper function to get distance between two touches
                const getTouchDistance = (touch1, touch2) => {
                    const dx = touch1.clientX - touch2.clientX;
                    const dy = touch1.clientY - touch2.clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                };

                // Mouse events
                canvas.addEventListener('mousedown', (event) => {
                    event.preventDefault();
                    isMouseDown = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                });

                canvas.addEventListener('mousemove', (event) => {
                    if (!isMouseDown) return;
                    event.preventDefault();

                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;

                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;

                    mouseX = event.clientX;
                    mouseY = event.clientY;
                });

                canvas.addEventListener('mouseup', (event) => {
                    event.preventDefault();
                    isMouseDown = false;
                });

                // Touch events
                canvas.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    isTouching = true;
                    
                    if (event.touches.length === 1) {
                        // Single touch - rotation
                        const touch = getTouchPos(event.touches[0]);
                        mouseX = touch.x;
                        mouseY = touch.y;
                    } else if (event.touches.length === 2) {
                        // Two touches - prepare for zoom
                        lastTouchDistance = getTouchDistance(event.touches[0], event.touches[1]);
                    }
                }, { passive: false });

                canvas.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    
                    if (!isTouching) return;

                    if (event.touches.length === 1) {
                        // Single touch - rotation
                        const touch = getTouchPos(event.touches[0]);
                        const deltaX = touch.x - mouseX;
                        const deltaY = touch.y - mouseY;

                        targetRotationY += deltaX * 0.02;
                        targetRotationX += deltaY * 0.02;

                        mouseX = touch.x;
                        mouseY = touch.y;
                    } else if (event.touches.length === 2) {
                        // Two touches - zoom
                        const currentDistance = getTouchDistance(event.touches[0], event.touches[1]);
                        const scale = lastTouchDistance / currentDistance;
                        
                        this.camera.position.multiplyScalar(scale);
                        this.camera.position.clampLength(5, 100);
                        
                        lastTouchDistance = currentDistance;
                    }
                }, { passive: false });

                canvas.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    if (event.touches.length === 0) {
                        isTouching = false;
                    }
                }, { passive: false });

                // Prevent context menu on long press
                canvas.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });

                // Mouse wheel for desktop
                canvas.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const scale = event.deltaY > 0 ? 1.1 : 0.9;
                    this.camera.position.multiplyScalar(scale);
                    this.camera.position.clampLength(5, 100);
                }, { passive: false });

                // Update camera position in animation loop
                this.updateCameraPosition = () => {
                    rotationX += (targetRotationX - rotationX) * 0.05;
                    rotationY += (targetRotationY - rotationY) * 0.05;

                    const distance = this.camera.position.length();
                    this.camera.position.x = distance * Math.sin(rotationY) * Math.cos(rotationX);
                    this.camera.position.y = distance * Math.sin(rotationX);
                    this.camera.position.z = distance * Math.cos(rotationY) * Math.cos(rotationX);
                    this.camera.lookAt(0, 0, 0);
                };
            }

            setupEventListeners() {
                // Shape selection
                document.querySelectorAll('.shape-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.shape-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        this.currentShape = btn.dataset.shape;
                        this.updateInputs();
                    });
                });

                // Unit selection
                document.querySelectorAll('.unit-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.unit-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        this.currentUnit = btn.dataset.unit;
                    });
                });

                // Color selection
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.color-btn.active').classList.remove('active');
                        btn.classList.add('active');
                        this.currentColor = btn.dataset.color;
                    });
                });

                // Buttons
                document.getElementById('showBtn').addEventListener('click', () => this.showShape());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearShape());
                document.getElementById('resetViewBtn').addEventListener('click', () => this.resetView());
                document.getElementById('toggleGridBtn').addEventListener('click', () => this.toggleGrid());
            }

            updateInputs() {
                const container = document.getElementById('inputsContainer');
                const shape = this.shapes[this.currentShape];
                
                container.innerHTML = '';
                
                shape.params.forEach((param, index) => {
                    const div = document.createElement('div');
                    div.className = 'input-group';
                    div.innerHTML = `
                        <label for="${param}">${shape.labels[index]}</label>
                        <input type="number" id="${param}" min="0.1" max="100" step="0.1" value="5">
                    `;
                    container.appendChild(div);
                });
            }

            getInputValues() {
                const shape = this.shapes[this.currentShape];
                const values = {};
                let isValid = true;

                shape.params.forEach(param => {
                    const input = document.getElementById(param);
                    const value = parseFloat(input.value);
                    
                    if (isNaN(value) || value < 0.1 || value > 100) {
                        input.style.borderColor = '#f44336';
                        isValid = false;
                    } else {
                        input.style.borderColor = '#e0e0e0';
                        values[param] = value * this.unitFactors[this.currentUnit];
                    }
                });

                return isValid ? values : null;
            }

            createGeometry(values) {
                switch (this.currentShape) {
                    case 'cube':
                        return new THREE.BoxGeometry(values.side, values.side, values.side);
                    
                    case 'cylinder':
                        return new THREE.CylinderGeometry(values.radius, values.radius, values.height, 32);
                    
                    case 'sphere':
                        return new THREE.SphereGeometry(values.radius, 32, 32);
                    
                    case 'pyramid':
                        return new THREE.ConeGeometry(values.base / Math.sqrt(2), values.height, 4);
                    
                    case 'cone':
                        return new THREE.ConeGeometry(values.radius, values.height, 32);
                    
                    case 'box':
                        return new THREE.BoxGeometry(values.length, values.height, values.width);
                    
                    default:
                        return new THREE.BoxGeometry(5, 5, 5);
                }
            }

            calculateStats(values) {
                const factor = this.unitFactors[this.currentUnit];
                const unit = this.currentUnit;
                const unit2 = unit + '¬≤';
                const unit3 = unit + '¬≥';

                let volume, surfaceArea, perimeter;

                switch (this.currentShape) {
                    case 'cube':
                        const side = values.side / factor;
                        volume = Math.pow(side, 3);
                        surfaceArea = 6 * Math.pow(side, 2);
                        perimeter = 12 * side;
                        break;
                    
                    case 'cylinder':
                        const r_cyl = values.radius / factor;
                        const h_cyl = values.height / factor;
                        volume = Math.PI * Math.pow(r_cyl, 2) * h_cyl;
                        surfaceArea = 2 * Math.PI * r_cyl * (r_cyl + h_cyl);
                        perimeter = 4 * Math.PI * r_cyl;
                        break;
                    
                    case 'sphere':
                        const r_sph = values.radius / factor;
                        volume = (4/3) * Math.PI * Math.pow(r_sph, 3);
                        surfaceArea = 4 * Math.PI * Math.pow(r_sph, 2);
                        perimeter = 2 * Math.PI * r_sph;
                        break;
                    
                    case 'pyramid':
                        const base_pyr = values.base / factor;
                        const h_pyr = values.height / factor;
                        volume = (1/3) * Math.pow(base_pyr, 2) * h_pyr;
                        const slantHeight = Math.sqrt(Math.pow(h_pyr, 2) + Math.pow(base_pyr/2, 2));
                        surfaceArea = Math.pow(base_pyr, 2) + 4 * (0.5 * base_pyr * slantHeight);
                        perimeter = 4 * base_pyr;
                        break;
                    
                    case 'cone':
                        const r_cone = values.radius / factor;
                        const h_cone = values.height / factor;
                        volume = (1/3) * Math.PI * Math.pow(r_cone, 2) * h_cone;
                        const slantHeight_cone = Math.sqrt(Math.pow(h_cone, 2) + Math.pow(r_cone, 2));
                        surfaceArea = Math.PI * r_cone * (r_cone + slantHeight_cone);
                        perimeter = 2 * Math.PI * r_cone;
                        break;
                    
                    case 'box':
                        const l = values.length / factor;
                        const w = values.width / factor;
                        const h = values.height / factor;
                        volume = l * w * h;
                        surfaceArea = 2 * (l*w + w*h + h*l);
                        perimeter = 4 * (l + w + h);
                        break;
                }

                return {
                    volume: volume.toFixed(2) + ' ' + unit3,
                    surfaceArea: surfaceArea.toFixed(2) + ' ' + unit2,
                    perimeter: perimeter.toFixed(2) + ' ' + unit
                };
            }

            showShape() {
                const values = this.getInputValues();
                if (!values) {
                    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è');
                    return;
                }

                this.clearShape();

                const geometry = this.createGeometry(values);
                const material = new THREE.MeshLambertMaterial({ 
                    color: this.currentColor,
                    transparent: true,
                    opacity: 0.9
                });

                this.currentMesh = new THREE.Mesh(geometry, material);
                this.currentMesh.castShadow = true;
                this.currentMesh.receiveShadow = true;
                this.scene.add(this.currentMesh);

                // Show stats
                const stats = this.calculateStats(values);
                this.showStats(stats);

                // Hide loading text
                document.getElementById('loadingText').style.display = 'none';
            }

            showStats(stats) {
                const panel = document.getElementById('statsPanel');
                const grid = document.getElementById('statsGrid');
                
                grid.innerHTML = `
                    <div class="stat-item">
                        <span class="stat-label">–û–±—ä–µ–º:</span>
                        <span class="stat-value">${stats.volume}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">–ü–ª–æ—â–∞–¥—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏:</span>
                        <span class="stat-value">${stats.surfaceArea}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">–ü–µ—Ä–∏–º–µ—Ç—Ä:</span>
                        <span class="stat-value">${stats.perimeter}</span>
                    </div>
                `;
                
                panel.style.display = 'block';
            }

            clearShape() {
                if (this.currentMesh) {
                    this.scene.remove(this.currentMesh);
                    this.currentMesh.geometry.dispose();
                    this.currentMesh.material.dispose();
                    this.currentMesh = null;
                }
                
                document.getElementById('statsPanel').style.display = 'none';
                document.getElementById('loadingText').style.display = 'block';
            }

            resetView() {
                this.camera.position.set(15, 15, 15);
                this.camera.lookAt(0, 0, 0);
            }

            toggleGrid() {
                this.gridHelper.visible = !this.gridHelper.visible;
                this.axesHelper.visible = !this.axesHelper.visible;
            }

            onWindowResize() {
                const container = this.renderer.domElement.parentElement;
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.updateCameraPosition) {
                    this.updateCameraPosition();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            new GeometryVisualizer();
        });
    </script>
</body>
</html>